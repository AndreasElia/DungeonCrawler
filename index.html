<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dungeon Crawler</title>
		<meta charset="utf-8">

		<style>
			body {
				background-color: #fff;
				color: #444;
				margin: 0px;
				overflow: hidden;
				font-family: Tahoma;
				font-size: 13px;
			}

			#stats {
				position: absolute;
				left: 0px;
				right: 0px;
			}

			#blocker {
				background-color: rgba(0, 0, 0, .5);
				width: 100%;
				height: 100%;
				position: absolute;
			}

			#instructions {
				width: 100%;
				height: 100%;
				color: #FFFFFF;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script src="js/stats.js"></script>
		<script src="js/pointerlockcontrols.js"></script>
		<script src="js/keyboard.js"></script>

<!-- 		<div id="blocker">
			<div id="instructions">
				Left Mouse to Start<br>
				(SPACE = Action, WASD = Move, MOUSE = Look around)
			</div>
		</div> -->

		<script>
			var element = document.body;

			var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 1, FAR = 1000;
			var UNITSIZE = 100, WALLSIZE = 16;

			var t = THREE, stats, loader;
			var scene, camera, renderer, clock, controls, key;

			var MAINMENU = 0,
				INSTRUCTIONS = 1,
				CREDITS = 2,
				INGAME = 3,
				PAUSED = 4;
			var GAMESTATE = 0;

			var pointerlockchange = function (event) {
				if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
					controlsEnabled = true;
					controls.enabled = true;
				} else {
					controls.enabled = false;
				}
			};

			var map = [
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 1, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
			];

			var objects = [];

			var velocity = new t.Vector3();
			var moveSpeed = 20;
			var speedIncrease = 100;

			var mouse = new t.Vector2();

			var canMove = {
				FORWARD: true,
				BACKWARD: true,
				LEFT: true,
				RIGHT: true,
			};

			var raycaster;

			init();
			animate();

			function init() {
				// CTRL+U = source, F12 = dev tools
				stats = new Stats();
				stats.setMode(0);
				document.body.appendChild(stats.domElement);

				// Creates a new WebGL Renderer (used to render everything inc. scene)
				renderer = new t.WebGLRenderer();
				// Sets the Renderer to the window width and height
				renderer.setSize(WIDTH, HEIGHT);
				// Add the renderers DOM element to the window
				document.body.appendChild(renderer.domElement);

				// Adds the keyboard class that handles keyboard input
				key = new Keyboard();

				// Raycaster for collisions
				raycaster = new t.Raycaster();

				// The texture loader allows textures to be loaded and kept track of
				loader = new t.TextureLoader();

				// Initialize the Clock so we can keep track of delta time etc
				clock = new t.Clock();

				// Creates a new scene object
				scene = new t.Scene();

				// create a new "Perspective" Camera
				camera = new t.PerspectiveCamera(75, ASPECT, NEAR, FAR);
				// Change the cameras position so it is centered within the map
				camera.position.y = UNITSIZE * 0.2;

				// Create a new init of the controls and pass in the camera as the object
				controls = new t.PointerLockControls(camera);
				// Add the controls object to the scene
				scene.add(controls.getObject());

				setupGame();
			}

			function setupGame() {
				document.addEventListener('pointerlockchange', pointerlockchange, false);
				document.addEventListener('mozpointerlockchange', pointerlockchange, false);
				document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
				document.addEventListener('click', function (event) {
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					element.requestPointerLock();
				}, false);

				// Adds fog to the scene
				scene.fog = new t.FogExp2(0x4a5635, 0.025);

				// Since the walls, floor and ceiling are made of boxes we create a box geometry for them
				// PlaneGeometry?
				var geometry = new t.CubeGeometry(10, 10, 10);

				// A list of textures that can be used in the map cubes (walls, floor, ceiling etc)
				var textures = [
					loader.load('textures/floor0.png'),
					loader.load('textures/wall0.png'),
					loader.load('textures/wall1.png'),
					loader.load('textures/ceiling0.png')
				];

				// Sets the filter for each texture making it pixelated rather than blurred
				for (var x = 0; x < textures.length; x++) {
					textures[x].magFilter = t.NearestFilter;
					textures[x].minFilter = t.NearestMipMapLinearFilter;
				}

				for (var y = 0; y < map.length; y++) {
					for (var x = 0; x < map[0].length; x++) {
						var val = map[y][x];

						switch(map[x][y]) {
							case 0:
								// Floor
								var floor = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[0], side: t.FrontSide}));
								floor.position.set(-20 + (x * 10), UNITSIZE * 0.2, -30 + (y * 10));
								scene.add(floor);

								// Ceiling
								var ceiling = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[3], side: t.FrontSide}));
								ceiling.position.set(-20 + (x * 10), UNITSIZE * 0.4, -30 + (y * 10));
								scene.add(ceiling);
								break;

							case 1:
								// Walls
								var wall = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[Math.floor(Math.random() * 2) + 1], side: t.FrontSide}));
								wall.position.set(-20 + (x * 10), UNITSIZE * 0.3, -30 + (y * 10));
								scene.add(wall);
								objects.push(wall);
								break;
						}
					}
				}
			}

			function animate() {
				stats.begin();

				update();
				render();

				stats.end();

				requestAnimationFrame(animate);
			}

			function update() {
				var delta = clock.getDelta();

				// if (controls.getMouse() != undefined) console.log("mouse position: " + controls.getMouse().x);

				if (key.down(key.FORWARD) && !collides(new t.Vector3(0, 0, -1), 5)) {
					if (velocity.z > -moveSpeed) {
						velocity.z -= speedIncrease * delta;
					}
				} else if (key.down(key.BACKWARD) && !collides(new t.Vector3(0, 0, 1), 5)) {
					if (velocity.z < moveSpeed) {
						velocity.z += speedIncrease * delta;
					}
				} else {
					velocity.z = 0;
				}

				if (key.down(key.LEFT) && !collides(new t.Vector3(-1, 0, 0), 5)) {
					if (velocity.x > -moveSpeed) {
						velocity.x -= speedIncrease * delta;
					}
				} else if (key.down(key.RIGHT) && !collides(new t.Vector3(1, 0, 0), 5)) {
					if (velocity.x < moveSpeed) {
						velocity.x += speedIncrease * delta;
					}
				} else {
					velocity.x = 0;
				}

				controls.getObject().translateX( velocity.x * delta );
				controls.getObject().translateY( velocity.y * delta );
				controls.getObject().translateZ( velocity.z * delta );
			}

			function collides(vec, dist) {
				raycaster.setFromCamera(vec, camera);
				var intersects = raycaster.intersectObjects(objects);
				return (intersects.length > 0 && intersects[0].distance < dist) ? true : false;
			}

			function render() {
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
