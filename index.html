<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dungeon Crawler</title>
		<meta charset="utf-8">

		<style>
			body {
				background-color: #fff;
				color: #444;
				margin: 0px;
				overflow: hidden;
				font-family: Tahoma;
				font-size: 13px;
			}

			#stats {
				position: absolute;
				left: 0px;
				right: 0px;
			}

			#blocker {
				background-color: rgba(0, 0, 0, .5);
				width: 100%;
				height: 100%;
				position: absolute;
			}

			#instructions {
				width: 100%;
				height: 100%;
				color: #FFFFFF;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script src="js/stats.js"></script>
		<script src="js/pointerlockcontrols.js"></script>

		<!--<div id="blocker">
			<div id="instructions">
				Left Mouse to Start<br>
				(SPACE = Action, WASD = Move, MOUSE = Look around)
			</div>
		</div>-->

		<script>
			var InputHandler = {
				_pressed: {},

				FORWARD: 87,
				BACKWARD: 83,
				LEFT: 65,
				RIGHT: 68,

				pressed: function(keyCode) {
					return this._pressed[keyCode];
				},

				onKeyUp: function(e) {
					delete this._pressed[e.keyCode];
				},

				onKeyDown: function(e) {
					this._pressed[e.keyCode] = true;
				}
			};

			window.addEventListener('keyup', function(e) {
				InputHandler.onKeyUp(e);
			});

			window.addEventListener('keydown', function(e) {
				InputHandler.onKeyDown(e);
			});

			var moveForward = true,
				moveBackward = false,
				moveLeft = false,
				moveRight = false;

			var element = document.body;

			var pointerlockchange = function (e) {
				if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
					controlsEnabled = true;
					controls.enabled = true;
				} else {
					controls.enabled = false;
				}
			};

			document.addEventListener('pointerlockchange', pointerlockchange, false);
			document.addEventListener('mozpointerlockchange', pointerlockchange, false);
			document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
			document.addEventListener('click', function (e) {
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
				element.requestPointerLock();
			}, false);

			var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 0.1, FAR = 1000;
			var UNIT = 100, WALLSIZE = 16;

			var t = THREE, stats, loader;
			var scene, camera, renderer, clock, controls;

			var MAINMENU = 0,
				INSTRUCTIONS = 1,
				CREDITS = 2,
				INGAME = 3,
				PAUSED = 4;
			var GAMESTATE = 0;

			var map = [
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 1, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
			];

			var velocity = new t.Vector3();
			var moveSpeed = 20, speedIncrease = 100;

			var walls = [];

			var rays = [
				new t.Vector3(0, 0, 1), 
				new t.Vector3(1, 0, 1), 
				new t.Vector3(1, 0, 0), 
				new t.Vector3(1, 0, -1), 
				new t.Vector3(0, 0, -1), 
				new t.Vector3(-1, 0, -1), 
				new t.Vector3(-1, 0, 0), 
				new t.Vector3(-1, 0, 1)
			];
			var mouse = new t.Vector2();

			var raycaster = new t.Raycaster();
			var camPos = new t.Vector3();

			var canMove = {
				FORWARD: true,
				BACKWARD: true,
				LEFT: true,
				RIGHT: true,
			};

			init();
			animate();

			function init() {
				// CTRL+U = source, F12 = dev tools
				stats = new Stats();
				stats.setMode(0);

				document.body.appendChild(stats.domElement);

				// Creates a new scene object
				scene = new t.Scene();
				// Adds fog to the scene
				scene.fog = new t.FogExp2(0x4a5635, 0.025);
				
				// create a new "Perspective" Camera
				camera = new t.PerspectiveCamera(75, ASPECT, NEAR, FAR);
				// Change the cameras position so it is centered within the map
				camera.position.y = UNIT * 0.2;

				// Creates a new WebGL Renderer (used to render everything inc. scene)
				renderer = new t.WebGLRenderer();
				// Sets the Renderer to the window width and height
				renderer.setSize(WIDTH, HEIGHT);
				// Add the renderers DOM element to the window
				document.body.appendChild(renderer.domElement);

				// Create a new init of the controls and pass in the camera as the object
				controls = new t.PointerLockControls(camera);
				// Add the controls object to the scene
				scene.add(controls.getObject());

				// Initialize the Clock so we can keep track of delta time etc
				clock = new t.Clock();

				// The texture loader allows textures to be loaded and kept track of
				loader = new t.TextureLoader();

				// Call a function to setup the scene
				setupScene();
			}

			function setupScene() {
				// scene.add(mouseControls.getObject());
				// Since the walls, floor and ceiling are made of boxes we create a box geometry for them
				var geometry = new t.CubeGeometry(10, 10, 10);

				// A list of textures that can be used in the map cubes (walls, floor, ceiling etc)
				var textures = [
					loader.load('textures/floor0.png'),
					loader.load('textures/wall0.png'),
					loader.load('textures/wall1.png'),
					loader.load('textures/ceiling0.png')
				];

				// Sets the filter for each texture making it pixelated rather than blurred
				for (var x = 0; x < textures.length; x++) {
					textures[x].magFilter = t.NearestFilter;
					textures[x].minFilter = t.NearestMipMapLinearFilter;
				}

				for (var y = 0; y < map.length; y++) {
					for (var x = 0; x < map[0].length; x++) {
						var val = map[y][x];
						var cube;

						if (val == 0) {
							cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[0], side: t.FrontSide}));
							cube.position.set(-20 + (x * 10), UNIT * 0.2, -30 + (y * 10));
							scene.add(cube);
							// walls.push(cube);

							cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[3], side: t.FrontSide}));
							cube.position.set(-20 + (x * 10), UNIT * 0.4, -30 + (y * 10));
							scene.add(cube);
							// walls.push(cube);
						}

						if (val == 1) {
							cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[Math.floor(Math.random() * 2) + 1], side: t.FrontSide}));
							// cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[Math.floor(Math.random() * 2) + 1], side: t.FrontSide, wireframe: true}));
							cube.position.set(-20 + (x * 10), UNIT * 0.3, -30 + (y * 10));
							scene.add(cube);
							walls.push(cube);
						}
					}
				}
			}

			function animate() {
				stats.begin();

				update();
				render();

				stats.end();
				requestAnimationFrame(animate);
			}

			function update() {
				var delta = clock.getDelta();

				if (InputHandler.pressed(InputHandler.FORWARD) && canMove.FORWARD) {
					if (velocity.z > -moveSpeed) {
						velocity.z -= speedIncrease * delta;
					}
				} else if (InputHandler.pressed(InputHandler.BACKWARD) && canMove.BACKWARD) {
					if (velocity.z < moveSpeed) {
						velocity.z += speedIncrease * delta;
					}
				} else {
					velocity.z = 0;
				}

				if (InputHandler.pressed(InputHandler.LEFT) && canMove.LEFT) {
					if (velocity.x > -moveSpeed) {
						velocity.x -= speedIncrease * delta;
					}
				} else if (InputHandler.pressed(InputHandler.RIGHT) && canMove.RIGHT) {
					if (velocity.x < moveSpeed) {
						velocity.x += speedIncrease * delta;
					}
				} else {
					velocity.x = 0;
				}

				controls.getObject().translateX(velocity.x * delta);
				controls.getObject().translateY(velocity.y * delta);
				controls.getObject().translateZ(velocity.z * delta);

				// if (velocity.x < 0 || velocity.x > 0 || velocity.z < 0 || velocity.z > 0) {}

				for (var j = 0; j < rays.length; j++) {
					raycaster.setFromCamera(rays[j], camera);
					var intersects = raycaster.intersectObjects(scene.children);

					for (var i = 0; i < intersects.length; i++) {
						if (intersects.length > 0 && intersects[i].distance < 3) {
							if ((i === 0 || i === 1 || i === 7) && velocity.z < 0) {
								canMove.FORWARD = false;
								velocity.z = -1;
							} else if ((i === 3 || i === 4 || i === 5) && velocity.z > 0) {
								canMove.BACKWARD = false;
								velocity.z = -1;
							} else {
								canMove.FORWARD = true;
								canMove.BACKWARD = true;
							}

							if ((i === 1 || i === 2 || i === 3) && velocity.x < 0) {
								canMove.LEFT = false;
								velocity.x = -1;
							} else if ((i === 5 || i === 6 || i === 7) && velocity.x > 0) {
								canMove.RIGHT = false;
								velocity.x = -1;
							} else {
								canMove.LEFT = true;
								canMove.RIGHT = true;
							}

							var geometry = new t.Geometry();
						    geometry.vertices.push(intersects[i].point);
						    geometry.vertices.push(controls.getObject().position);
						    scene.remove(rayLine);

						    var rayLine = new t.Line(geometry, new t.LineBasicMaterial({color: 0xFF00FF, linewidth: 2}));
						    scene.add(rayLine);

							intersects[i].object.material.color.set(0xff0000);
						}		            
					}
				}
			}

			function render() {
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
