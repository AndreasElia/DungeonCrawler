<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dungeon Crawler</title>
		<meta charset="utf-8">

		<style>
			body {
				background-color: #fff;
				color: #444;
				margin: 0px;
				overflow: hidden;
				font-family: Tahoma;
				font-size: 13px;
			}

			#stats {
				position: absolute;
				left: 0px;
				right: 0px;
			}

			#blocker {
				background-color: rgba(0, 0, 0, .5);
				width: 100%;
				height: 100%;
				position: absolute;
			}

			#instructions {
				width: 100%;
				height: 100%;
				color: #FFFFFF;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script src="js/stats.js"></script>
		<script src="js/pointerlockcontrols.js"></script>

		<!--<div id="blocker">
			<div id="instructions">
				Left Mouse to Start<br>
				(SPACE = Action, WASD = Move, MOUSE = Look around)
			</div>
		</div>-->

		<script>
			var InputHandler = {
				_pressed: {},

				FORWARD: 87,
				BACKWARD: 83,
				LEFT: 65,
				RIGHT: 68,

				pressed: function(keyCode) {
					return this._pressed[keyCode];
				},

				onKeyUp: function(e) {
					delete this._pressed[e.keyCode];
				},

				onKeyDown: function(e) {
					this._pressed[e.keyCode] = true;
				}
			};

			window.addEventListener('keyup', function(e) {
				InputHandler.onKeyUp(e);
			});

			window.addEventListener('keydown', function(e) {
				InputHandler.onKeyDown(e);
			});

			var moveForward = true,
				moveBackward = false,
				moveLeft = false,
				moveRight = false;

			var element = document.body;

			var pointerlockchange = function (e) {
				if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
					controlsEnabled = true;
					controls.enabled = true;
				} else {
					controls.enabled = false;
				}
			};

			document.addEventListener('pointerlockchange', pointerlockchange, false);
			document.addEventListener('mozpointerlockchange', pointerlockchange, false);
			document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
			document.addEventListener('click', function (e) {
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
				element.requestPointerLock();
			}, false);

			var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = .1,
				FAR = 1000;
			var UNIT = 100,
				WALLSIZE = 16;

			var t = THREE,
				stats, scene, camera, renderer, clock, controls, loader;

			var MAINMENU = 0,
				INSTRUCTIONS = 1,
				CREDITS = 2,
				INGAME = 3,
				PAUSED = 4;
			var GAMESTATE = 0;

			var collisions = [];

			var map = [
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 1, 0, 1, 1, 0, 1], 
				[1, 0, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 1, 0, 1, 0, 0, 1, 0, 0, 1], 
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
				[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
			];
			var mapWidth = map.length,
				mapHeight = map[0].length;

			var raycaster;
			var velocity = new t.Vector3();

			init();
			animate();

			function init() {
				// CTRL+U = source, F12 = dev tools
				stats = new Stats();
				stats.setMode(0);

				document.body.appendChild(stats.domElement);

				// Creates a new scene object
				scene = new t.Scene();
				// Adds fog to the scene
				scene.fog = new t.FogExp2(0x4a5635, 0.025);
				
				// create a new "Perspective" Camera
				camera = new t.PerspectiveCamera(75, ASPECT, NEAR, FAR);
				// Change the cameras position so it is centered within the map
				camera.position.y = UNIT * .2;

				// Creates a new WebGL Renderer (used to render everything inc. scene)
				renderer = new t.WebGLRenderer();
				// Sets the Renderer to the window width and height
				renderer.setSize(WIDTH, HEIGHT);
				// Add the renderers DOM element to the window
				document.body.appendChild(renderer.domElement);

				// Create a new init of the controls and pass in the camera as the object
				controls = new t.PointerLockControls(camera);
				// Add the controls object to the scene
				scene.add(controls.getObject());

				// Initialize the Clock so we can keep track of delta time etc
				clock = new t.Clock();

				// Raycaster for collision
				//raycaster = new t.Raycaster();
				raycaster = new t.Raycaster(new t.Vector3(), new t.Vector3(0, UNIT * .2, 0), NEAR, FAR);

				// The texture loader allows textures to be loaded and kept track of
				loader = new t.TextureLoader();

				// Call a function to setup the scene
				setupScene();
			}

			function setupScene() {
				// scene.add(mouseControls.getObject());
				// Since the walls, floor and ceiling are made of boxes we create a box geometry for them
				var geometry = new t.CubeGeometry(10, 10, 10);

				// A list of textures that can be used in the map cubes (walls, floor, ceiling etc)
				var textures = [
					loader.load('textures/floor0.png'),
					loader.load('textures/wall0.png'),
					loader.load('textures/wall1.png'),
					loader.load('textures/ceiling0.png')
				];

				// Sets the filter for each texture making it pixelated rather than blurred
				for (var x = 0; x < textures.length; x++) {
					textures[x].magFilter = t.NearestFilter;
					textures[x].minFilter = t.NearestMipMapLinearFilter;
				}

				for (var i = 0; i < mapWidth; i++) {
					for (var j = 0; j < mapHeight; j++) {
						// If the current map array value is 0 then we know its empty space, else it's a wall
						if (map[i][j] == 0) {
							// Assign the correct geometry and texture
							var cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[0], side: t.FrontSide}));
							// Set the position to the floor level
							cube.position.set(-30 + (i * 10), UNIT * .2, -30 + (j * 10));
							// Add the cube to the scene
							scene.add(cube);
							collisions.push(cube);

							var cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[3], side: t.FrontSide}));
							// Set the position to the ceiling level
							cube.position.set(-30 + (i * 10), UNIT * .4, -30 + (j * 10));
							scene.add(cube);
							collisions.push(cube);
						} else if (map[i][j] == 1) {
							var cube = new t.Mesh(geometry, new t.MeshBasicMaterial({map: textures[Math.floor(Math.random() * 2) + 1], side: t.FrontSide}));
							// Set the position to the wall level
							cube.position.set(-30 + (i * 10), UNIT * .3, -30 + (j * 10));
							scene.add(cube);
							collisions.push(cube);
						}
					}
				}
			}

			function animate() {
				stats.begin();

				update();
				render();

				stats.end();
				requestAnimationFrame(animate);
			}

			function update() {
				var delta = clock.getDelta();

				if (InputHandler.pressed(InputHandler.FORWARD)) {
					velocity.z -= 100.0 * delta;
				} else if (InputHandler.pressed(InputHandler.BACKWARD)) {
					velocity.z += 100.0 * delta;
				} else if (InputHandler.pressed(InputHandler.LEFT)) {
					velocity.x -= 100.0 * delta;
				} else if (InputHandler.pressed(InputHandler.RIGHT)) {
					velocity.x += 100.0 * delta;
				} else {
					velocity.z = 0;
					velocity.x = 0;
				}

				controls.getObject().translateX(velocity.x * delta);
				controls.getObject().translateY(velocity.y * delta);
				controls.getObject().translateZ(velocity.z * delta);

				raycaster.ray.origin.copy( controls.getObject().position );
				var intersections = raycaster.intersectObjects( collisions );
				var isOnObject = intersections.length > 0;
				console.log((isOnObject) ? true : false);
			}

			function render() {
				renderer.render(scene, camera);
			}

			function onMouseMove(ev) {
				mouse[0] = ev.clientX / window.innerWidth;
				mouse[1] = ev.clientY / window.innerHeight;
			}

			function onMouseWheel(ev) {
				var amount = -ev.wheelDeltaY || ev.detail;
				if ( amount === 0 ) return;
				var dir = amount / Math.abs(amount);
				zoomspeed = dir/10;

				// Slow down default zoom speed after user starts zooming, to give them more control
				minzoomspeed = 0.001;
			}
		</script>
	</body>
</html>
